#!/usr/bin/env bash
#
# @PACKAGE_NAME@ ${script_name}"
# Version: @PACKAGE_VERSION@"
# Home: @PACKAGE_URL@"
#

source "${SCRIPT_TOP}/audx-str-lib.sh"

print_project_banner() {
	echo "${script_name} (@PACKAGE_NAME@) version @PACKAGE_VERSION@"
}

print_project_info() {
	echo "  @PACKAGE_NAME@ ${script_name}"
	echo "  Version: @PACKAGE_VERSION@"
	echo "  Project Home: @PACKAGE_URL@"
}

on_exit() {
	local result=${1}

	local sec="${SECONDS}"

	if [[ -d "${tmp_dir:-}" ]]; then
		if [[ ${keep_tmp_dir:-} ]]; then
			echo "${script_name}: INFO: tmp dir preserved: '${tmp_dir}'" >&2
		else
			rm -rf "${tmp_dir:?}"
		fi
	fi

	if (( sec < 3600 )); then
		set +x
		echo "${script_name}: Done: ${result}, ${sec} sec ($(sec_to_min "${sec}") min)." >&2
	else
		set +x
		echo "${script_name}: Done: ${result}, $(sec_to_min "${sec}") min ($(sec_to_hour "${sec}") hour)." >&2
	fi
}

on_err() {
	local f_name=${1}
	local line_no=${2}
	local err_no=${3}

	{
		if [[ ${on_err_debug:-} ]]; then
			echo '------------------------'
			set
			echo '------------------------'
		fi
		echo "${script_name}: ERROR: function=${f_name}, line=${line_no}, result=${err_no}"
	} >&2

	exit "${err_no}"
}

sec_to_min() {
	local sec=${1}

	local min
	local frac_10
	local frac_100

	min=$(( sec / 60 ))
	frac_10=$(( (sec - min * 60) * 10 / 60 ))
	frac_100=$(( (sec - min * 60) * 100 / 60 ))

	if (( frac_10 != 0 )); then
		frac_10=''
	fi

	echo "${min}.${frac_10}${frac_100}"
}

sec_to_hour() {
	local sec=${1}

	local hour
	local frac_10
	local frac_100

	hour=$(( sec / 3600 ))
	frac_10=$(( (sec - hour * 3600) * 10 / 3600 ))
	frac_100=$(( (sec - hour * 3600) * 100 / 3600 ))

	if (( frac_10 != 0 )); then
		frac_10=''
	fi

	echo "${hour}.${frac_10}${frac_100}"
}

verbose_echo() {
	local msg="${*}"

	if [[ "${verbose:-}" &&  "${verbose:-}" == 'y' || "${verbose:-}" == '1' ]]; then
		echo "${msg}"
		return
	fi

	if [[ "${quiet:-}" &&  "${quiet:-}" != 'y' && "${quiet:-}" != '1' ]]; then
		echo "${msg}"
	fi
}

cpu_count() {
	local result

	if result="$(getconf _NPROCESSORS_ONLN)"; then
		echo "${result}"
	else
		echo "1"
	fi
}

get_bool_opt() {
	local opt=${1}
	local value=${2}
	local out

	case "${value}" in
	y | yes | 1)
		out='y'
		;;
	n | no | 0)
		out='n'
		;;
	*)
		echo "${FUNCNAME[0]}: ERROR: Unknown value: ${opt} = '${value}'" >&2
		usage
		exit 1
		;;
	esac

	# echo "${FUNCNAME[0]}: ${opt} '${value}' => '${out}'" >&2
	echo "${out}"
}

check_dir_exists() {
	local msg="${1}"
	local dir="${2}"

	if [[ ! -d "${dir}" ]]; then
		echo "${script_name}: ERROR: ${msg} not found: '${dir}'" >&2
		exit 1
	fi
}

check_does_not_exist() {
	local msg="${1}"
	local dir="${2}"

	if [[ -f ${dir} ]]; then
		echo "${script_name}: ERROR: ${msg} file exists: '${dir}'." >&2
		exit 1
	fi
	if [[ -d ${dir} ]]; then
		echo "${script_name}: ERROR: ${msg} directory exists: '${dir}'." >&2
		exit 1
	fi
	if [[ -e ${dir} ]]; then
		echo "${script_name}: ERROR: ${msg} exists: '${dir}'." >&2
		exit 1
	fi
}

check_file() {
	local msg="${1}"
	local file="${2}"

	if [[ ! -f "${file}" ]]; then
		echo "${script_name}: ERROR: ${msg} not found: '${file}'" >&2
		exit 1
	fi
}

move_file() {
	local src=${1}
	local dest=${2}

	check_file 'source file' "${src}"

	local echo_extra
	if [[ ${dry_run:-} ]]; then
		echo_extra=' (dry run)'
	else
		echo_extra=''
	fi

	if [[ ${verbose} ]]; then
		echo "${FUNCNAME[0]}${echo_extra}: '${src}' -> '${dest}'"
	else
		echo "${FUNCNAME[0]}${echo_extra}: -> '${dest}'"
	fi

	if [[ ! ${dry_run:-} ]]; then
		mkdir -p "${dest%/*}"
		mv --no-clobber "${src}" "${dest}"
	fi
}

check_program() {
	local prog="${1}"
	local path="${2}"

	if ! test -x "$(command -v "${path}")"; then
		echo "${script_name}: ERROR: Please install '${prog}'." >&2
		exit 1
	fi
}

check_opt() {
	option=${1}
	value="${2}"

	if [[ ! ${value} ]]; then
		echo "${script_name}: ERROR (${FUNCNAME[0]}): Must provide ${option} option." >&2
		usage
		exit 1
	fi
}

check_if_positive() {
	local name=${1}
	local val=${2}

	if [[ ! ${val##*[![:digit:]]*} || "${val}" -lt 1 ]]; then
		echo "${script_name}: ERROR: ${name} must be a positive integer.  Got '${val}'." >&2
		usage
		exit 1
	fi
}

check_top_dir() {
	local top_dir="${1}"

	if [[ ! ${top_dir} ]]; then
		echo "${script_name}: ERROR: No top-dir given." >&2
		usage
		exit 1
	fi

	if [[ ! -d ${top_dir} ]]; then
		echo "${script_name}: ERROR: Bad top-dir: '${top_dir}'" >&2
		usage
		exit 1
	fi
}

check_src_dirs() {
	local sd=("${@}")

	#echo "${FUNCNAME[0]}: src dirs: @${@}@" >&2
	#echo "${FUNCNAME[0]}: count: @${#sd[@]}@" >&2

	if [[ ${#sd[@]} -eq 0 ]]; then
		echo "${script_name}: ERROR: No source directories given." >&2
		usage
		exit 1
	fi

	for ((i = 0; i < ${#sd[@]}; i++)); do
		if [[ -d "${sd[i]}" ]]; then
			[[ ${debug} ]] && echo "${FUNCNAME[0]}: [$((i + 1))] '${sd[i]}' OK." >&2
		else
			echo "${script_name}: ERROR: Bad source directory: [$((i + 1))] '${sd[i]}'." >&2
			usage
			exit 1
		fi
	done
	[[ ${debug} ]] && echo "" >&2
	return 0
}

delete_empty_paths() {
	local dir=${1}
	local dry_run=${2}

	{
		if [[ ${dry_run} ]]; then
			echo "${script_name}: INFO: Empty directories:"
			find "${dir}" -depth -type d -empty
			echo "${script_name}: INFO: Empty files:"
			find "${dir}" -depth -type f -empty
		else
			echo "${script_name}: INFO: Removing empty directories:"
			find "${dir}" -depth -type d -empty -print -delete
			echo "${script_name}: INFO: Removing empty files:"
			find "${dir}" -depth -type f -empty -print -delete
		fi
	} >&2
}

find_first_file() {
	local dir=${1}
	local start=${2}
	local end=${3}
	local verbose=${4}

# 	verbose=1

# 	echo "" >&2
# 	echo "${FUNCNAME[0]}>------------------------" >&2
# 	echo "${FUNCNAME[0]}: dir   = '${dir}'" >&2
# 	echo "${FUNCNAME[0]}: start = '${start}'" >&2
# 	echo "${FUNCNAME[0]}: end   = '${end}'" >&2

	local found
	found="$(find "${dir}" -type f \( -name '*.flac' -o -name '*.m4a' \) -newermt "${start}" \
		! -newermt "${end}" -print -quit)"

	local date
	if [[ ${verbose} ]]; then
		if [[ ${found} ]]; then
			date="$(date --date="$(stat --format='%y' "${found}")" '+%Y-%m-%d')"
			echo "${FUNCNAME[0]}: OK: (${date}) '${dir}'" >&2
		else
			local file
			file="$(find "${dir}" -type f -type f \( -name '*.flac' -o -name '*.m4a' \) -print -quit)"
			date="$(date --date="$(stat --format='%y' "${file}")" '+%Y-%m-%d')"
			echo "${FUNCNAME[0]}: NG: (${date}) '${dir}'" >&2
		fi
	fi
# 	echo "${FUNCNAME[0]}<------------------------" >&2
	echo "${found}"
}

slash_count() {
	local path=${1}
	local count

	count="${path//[^\/]/}"
	echo "${#count}"
}

path_to_artist_album() {
	local path=${1}
	local -n _path_to_artist_album__pair="${2}"

	local regex="^.*/([^/]*)/([^/]*)$"

	if [[ ! "${path}" =~ ${regex} ]]; then
		echo "${FUNCNAME[0]}: ERROR: No match '${path}'" >&2
		exit 1
	fi

	_path_to_artist_album__pair[ARTIST]="${BASH_REMATCH[1]}"
	_path_to_artist_album__pair[ALBUM]="${BASH_REMATCH[2]}"

	if [[ ${debug} ]]; then
	{
		echo "${FUNCNAME[0]}: ARTIST:  '${_path_to_artist_album__pair[ARTIST]}'"
		echo "${FUNCNAME[0]}: ALBUM: '${_path_to_artist_album__pair[ALBUM]}'"
	} >&2
	fi
}

path_to_artist_album_title() {
	local path=${1%.*}
	local -n _path_to_artist_album_title__triple="${2}"

	local regex="^.*/([^/]*)/([^/]*)/([^/]*)$"

	if [[ ! "${path}" =~ ${regex} ]]; then
		echo "${FUNCNAME[0]}: ERROR: No match '${path}'" >&2
		exit 1
	fi

	_path_to_artist_album_title__triple[ARTIST]="${BASH_REMATCH[1]}"
	_path_to_artist_album_title__triple[ALBUM]="${BASH_REMATCH[2]}"
	_path_to_artist_album_title__triple[TITLE]="${BASH_REMATCH[3]}"

	if [[ ${debug} ]]; then
	{
		echo "${FUNCNAME[0]}: ARTIST:  '${_path_to_artist_album_title__triple[ARTIST]}'"
		echo "${FUNCNAME[0]}: ALBUM: '${_path_to_artist_album_title__triple[ALBUM]}'"
		echo "${FUNCNAME[0]}: TITLE: '${_path_to_artist_album_title__triple[TITLE]}'"
	} >&2
	fi
}

clean_vfat_name() {
	local str_in=${1}
	local str_out="${str_in}"

	str_out="$(str_clean_parentheses "${str_out}")"
	str_out="$(str_clean_colon "${str_out}")"
	str_out="$(str_clean_common "${str_out}")"
	str_out="$(str_trim_space "${str_out}")"

	if [[ ${debug} ]]; then
		echo "${FUNCNAME[0]}: '${str_in}' -> '${str_out}'" >&2
	elif [[ ${verbose} && "${str_in}" != "${str_out}" ]]; then
		echo "${FUNCNAME[0]}: '${str_in}' -> '${str_out}'" >&2
	fi

	echo "${str_out}"
}

flac_clean_tag() {
	# known opts = and_the, filename.
	local str_in=${1}
	local -n _flac_clean_tag__opts="${2}"
	local str_out="${str_in}"

	str_out="${str_out//ACDC/AC-DC}"
	str_out="${str_out//AC\/DC/AC-DC}"

	str_out="${str_out//U S A /USA}"
	str_out="${str_out//W M A /WMA}"

	# str_out="${str_out//The Times They Are A‐Changin/The times They are a Changin}"
	# str_out="${str_out//I Dont Want Your Love (Shep Pettibone 7″ mix)/I Dont Want Your Love (Shep Pettibone)}"

	str_out="$(str_clean_parentheses "${str_out}")"
	str_out="$(str_clean_colon "${str_out}")"
	str_out="$(str_clean_disc "${str_out}")"
	str_out="$(str_clean_common "${str_out}")"
	str_out="$(str_clean_phrase "${str_out}")"

	if [[ ${_flac_clean_tag__opts[and_the]:-} ]]; then
		str_out="$(str_clean_and_the "${str_out}")"
	fi

	if [[ ${_flac_clean_tag__opts[filename]:-} ]]; then
		str_out="$(str_clean_filename "${str_out}")"
	fi

	str_out="$(str_trim_space "${str_out}")"

# 	if [[ ${verbose} && "${str_in}" != "${str_out}" ]]; then
# 		echo "'${str_in}' -> '${str_out}'" >&2
# 	fi

	echo "${str_out}"
}

flac_check_file() {
	local file=${1}
	local quiet=${2}

	if [[ "$(file -k "${file}")" != *'FLAC audio'* ]]; then
		if [[ "${quiet}" != 'quiet' ]]; then
			echo "${FUNCNAME[0]}: Not a flac file: '${file}'" >&2
		fi
		return 1
	fi
	return 0
}

flac_split_tag() {
	local tag=${1}
	local -n _flac_split_tag__pair="${2}"

	local regex_tag="([^=]+)=([^=]+)"

	if [[ ! "${tag}" =~ ${regex_tag} ]]; then
		echo "${FUNCNAME[0]}: ERROR: No match '${tag}'" >&2
		return 1
	fi

	_flac_split_tag__pair[name]="${BASH_REMATCH[1]}"
	_flac_split_tag__pair[value]="${BASH_REMATCH[2]}"

	if [[ ${debug} ]]; then
	{
		echo "${FUNCNAME[0]}: name:  '${_flac_split_tag__pair[name]}'"
		echo "${FUNCNAME[0]}: value: '${_flac_split_tag__pair[value]}'"
	} >&2
	fi

	return 0
}

flac_get_tag() {
	local t_name=${1}
	local file=${2}
	local optional=${3}

	if [[ "${optional}" != 'optional' && "${optional}" != 'required' ]]; then
		echo "${FUNCNAME[0]}: ERROR: Bad optional '${optional}'" >&2
		exit 1
	fi

	local tag

	tag="$("${metaflac}" --show-tag="${t_name}" "${file}")"

	local regex_tag="[^=]+=([^=]+)"

	if [[ ! "${tag}" =~ ${regex_tag} ]]; then
		if [[ ${optional} == 'optional' ]]; then
			return
		fi
		echo "${FUNCNAME[0]}: ERROR: Required tag '${t_name}' not found in '${tag}' file '${file}'." >&2
		exit 1
	fi

	if [[ ${debug} ]]; then
		echo "${FUNCNAME[0]}: INFO: '${tag}' => '${BASH_REMATCH[1]}'." >&2
	fi

	echo "${BASH_REMATCH[1]}"
}

flac_print_tag_set() {
	local msg="${1}"
	local file="${2}"
	local -n _flac_print_tag_set__tags="${3}"

	echo "${msg}file: '${file}'"
	echo "${msg}  ARTIST:      '${_flac_print_tag_set__tags[ARTIST]}'"
	echo "${msg}  ALBUM:       '${_flac_print_tag_set__tags[ALBUM]}'"
	echo "${msg}  TITLE:       '${_flac_print_tag_set__tags[TITLE]}'"
	echo "${msg}  TRACKNUMBER: '${_flac_print_tag_set__tags[TRACKNUMBER]}'"
	echo "${msg}  TRACKTOTAL:  '${_flac_print_tag_set__tags[TRACKTOTAL]}'"
	echo "${msg}  CDDB:        '${_flac_print_tag_set__tags[CDDB]}'"
}

add_leading_zero() {
	local -n _add_leading_zero_number="${1}"

	_add_leading_zero_number="${_add_leading_zero_number#0}"

	if (( ${_add_leading_zero_number} < 10 )); then
		_add_leading_zero_number="0${_add_leading_zero_number}"
	fi

	if [[ ${debug} ]]; then
		echo "_add_leading_zero_number= '${_add_leading_zero_number}'" >&2
	fi
}

flac_fill_tag_set() {
	local file="${1}"
	local -n _flac_fill_tag_set__tags="${2}"

	if ! flac_check_file "${file}" 'quiet'; then
		return
	fi

	_flac_fill_tag_set__tags[ARTIST]="$(flac_get_tag 'ARTIST' "${file}" 'required')"
	_flac_fill_tag_set__tags[ALBUM]="$(flac_get_tag 'ALBUM' "${file}" 'required')"
	_flac_fill_tag_set__tags[TITLE]="$(flac_get_tag 'TITLE' "${file}" 'required')"
	_flac_fill_tag_set__tags[TRACKNUMBER]="$(flac_get_tag "TRACKNUMBER" "${file}" 'required')"
	_flac_fill_tag_set__tags[TRACKTOTAL]="$(flac_get_tag "TRACKTOTAL" "${file}" 'optional')"
	_flac_fill_tag_set__tags[CDDB]="$(flac_get_tag "CDDB" "${file}" 'optional')"

	_flac_fill_tag_set__tags[TRACKNUMBER]="${_flac_fill_tag_set__tags[TRACKNUMBER]#0}"

	if [[ ${debug} ]]; then
		flac_print_tag_set "${FUNCNAME[0]}" "${file}" _flac_fill_tag_set__tags
	fi
}

flac_write_tag_set() {
	local file="${1}"
	local -n _flac_write_tag_set__tags="${2}"

	if ! flac_check_file "${file}" 'verbose'; then
		return
	fi

	"${metaflac}" --preserve-modtime --remove-tag='ARTIST' --set-tag="ARTIST=${_flac_write_tag_set__tags[ARTIST]}" "${file}"
	"${metaflac}" --preserve-modtime --remove-tag='ALBUM' --set-tag="ALBUM=${_flac_write_tag_set__tags[ALBUM]}" "${file}"
	"${metaflac}" --preserve-modtime --remove-tag='TITLE' --set-tag="TITLE=${_flac_write_tag_set__tags[TITLE]}" "${file}"
	"${metaflac}" --preserve-modtime --remove-tag='TRACKNUMBER' --set-tag="TRACKNUMBER=${_flac_write_tag_set__tags[TRACKNUMBER]}" "${file}"
	"${metaflac}" --preserve-modtime --remove-tag='TRACKTOTAL' --set-tag="TRACKTOTAL=${_flac_write_tag_set__tags[TRACKTOTAL]}" "${file}"

	if [[ ${_flac_write_tag_set__tags[CDDB]} ]]; then
		"${metaflac}" --preserve-modtime --remove-tag='CDDB' --set-tag="CDDB=${_flac_write_tag_set__tags[CDDB]}" "${file}"
	fi

	if [[ ${debug} ]]; then
		flac_print_tag_set "${FUNCNAME[0]}" "${file}" _flac_write_tag_set__tags
	fi
}

flac_print_vorbis_comment() {
	local file=${1}

	if ! flac_check_file "${file}" 'quiet'; then
		return
	fi

	echo "${FUNCNAME[0]}: file: '${file}'"
	"${metaflac}" --list --block-type=VORBIS_COMMENT "${file}"
	echo ''
}

flac_print_tags() {
	local file=${1}

	if ! flac_check_file "${file}" 'quiet'; then
		return
	fi

	declare -A tags

	flac_fill_tag_set "${file}" tags
	flac_print_tag_set '' "${file}" tags
}

metaflac_retag() {
	local file=${1}
	local tag_name=${2}
	local tag_data=${3}
	local op=${4}

	if ! flac_check_file "${file}" 'verbose'; then
		return
	fi

	local old_tag

	case "${op}" in
	'add')
		old_tag="$(flac_get_tag "${tag_name}" "${file}" 'optional')"
		;;
	'update')
		old_tag="$(flac_get_tag "${tag_name}" "${file}" 'required')"
		;;
	*)
		echo "${FUNCNAME[0]}: ERROR: Bad op: '${op}'" >&2
		exit 1
		;;
	esac

	{
		echo "${FUNCNAME[0]}: file: '${file}'"
		echo "${FUNCNAME[0]}:   ${tag_name}: '${old_tag}' => '${tag_data}'"
	}

	if [[ ! ${dry_run:-} ]]; then
		${metaflac} --preserve-modtime --remove-tag="${tag_name}" --set-tag="${tag_name}=${tag_data}" "${file}"
	fi
}

flac_meta_path() {
	local type=${1} # artist, various
	local src=${2}

	if ! flac_check_file "${src}" 'verbose'; then
		return
	fi

	declare -A tags

	flac_fill_tag_set "${src}" tags

	if [[ ${debug} ]]; then
		flac_print_tag_set "${FUNCNAME[0]}" "${src}" tags
	fi

	add_leading_zero tags[TRACKNUMBER]

	local dest

	case "${type}" in
	artist)
		dest="${tags[ARTIST]}/${tags[ALBUM]}/${tags[TRACKNUMBER]}-${tags[TITLE]}.flac"
		;;
	various)
		dest="Various Artists/${tags[ALBUM]}/${tags[TRACKNUMBER]}-${tags[ARTIST]} - ${tags[TITLE]}.flac"
		;;
	*)
		echo "${script_name}: ERROR: Internal: Bad type '${type}'" >&2
		exit 1
		;;
	esac

	echo "${dest}"
}

write_m3u_header() {
	local out_file=${1}
	local info=${2}
	local artist=${3}
	local album=${4}

	echo '#EXTM3U' >> "${out_file}"
	echo "#PLAYLIST: ${info}" >> "${out_file}"
	echo "#EXTART: ${artist}" >> "${out_file}"
	echo "#EXTALB: ${album}" >> "${out_file}"
	echo '' >> "${out_file}"
}

write_m3u_playlist() {
	local out_file=${1}
	local dir=${2}
	local type=${3}
	local canonical=${4}

	local files_array
	readarray -t files_array < <( find "${dir}" -maxdepth 1 -type f -name "*.${type}" | sort -n \
		|| { echo "${script_name}: ERROR: files_array find failed, function=${FUNCNAME[0]:-main}, line=${LINENO}, result=${?}" >&2; \
		kill -SIGUSR1 $$; } )

	if (( ${#files_array[@]} == 0 )); then
		if [[ ${verbose} ]]; then
			echo "${script_name}: No ${type} found: '${dir}'" >&2
		fi
		return
	fi

	local cddbid
	cddbid="$(flac_get_tag "CDDB" "${files_array[0]}" 'optional')"

	if [[ ! ${cddbid} ]]; then
		echo "${script_name}: WARNING: No CDDB tag found: '${files_array[0]}'" >&2
	fi

# 	TODO: Need an empty check with header.
# 	declare -A pair
# 	path_to_artist_album "${dir}" pair
# 	write_m3u_header "${out_file}" '@PACKAGE_NAME@ playlist' "${pair[ARTIST]}" "${pair[ALBUM]}"

	echo '#EXTM3U' > "${out_file}"
	echo "#CDDB=${cddbid}" >> "${out_file}"
	echo '' >> "${out_file}"

	if [[ ! ${canonical} ]]; then
		local i
		for (( i = 0; i < ${#files_array[@]}; i++ )); do
			files_array[i]="${files_array[i]##*/}"
		done
	fi

	printf "%s\n" "${files_array[@]}" >> "${out_file}"
	echo "${script_name}: Wrote ${#files_array[@]} ${type} entries: '${out_file}'" >&2
}
